
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>parental-control: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">parental-control/cmd/parental-control/main.go (0.0%)</option>
				
				<option value="file1">parental-control/internal/config/config.go (71.6%)</option>
				
				<option value="file2">parental-control/internal/database/db.go (80.2%)</option>
				
				<option value="file3">parental-control/internal/logging/logger.go (79.2%)</option>
				
				<option value="file4">parental-control/internal/models/entities.go (97.1%)</option>
				
				<option value="file5">parental-control/internal/models/repository.go (100.0%)</option>
				
				<option value="file6">parental-control/internal/service/service.go (87.3%)</option>
				
				<option value="file7">parental-control/internal/testutil/testutil.go (85.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"

        "parental-control/internal/logging"
        "parental-control/internal/service"
)

// Version information - will be injected at build time
var (
        Version   = "dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        var (
                showVersion = flag.Bool("version", false, "Show version information")
                configPath  = flag.String("config", "", "Path to configuration file")
        )
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Parental Control Service\n")
                fmt.Printf("Version: %s\n", Version)
                fmt.Printf("Build Time: %s\n", BuildTime)
                fmt.Printf("Git Commit: %s\n", GitCommit)
                os.Exit(0)
        }</span>

        // Initialize logging
        <span class="cov0" title="0">logger := logging.NewDefault()
        logging.SetGlobalLogger(logger)

        logging.Info("Starting Parental Control Service", logging.String("version", Version))

        // Create service configuration
        serviceConfig := service.DefaultConfig()
        if *configPath != "" </span><span class="cov0" title="0">{
                // TODO: Load configuration from file when configuration management is implemented
                logging.Info("Using config file", logging.String("path", *configPath))
        }</span>

        // Create and start the service
        <span class="cov0" title="0">svc := service.New(serviceConfig)
        
        if err := svc.Start(); err != nil </span><span class="cov0" title="0">{
                logging.Fatal("Failed to start service", logging.Err(err))
        }</span>

        // Wait for the service to stop (either via signal or error)
        <span class="cov0" title="0">svc.Wait()
        
        logging.Info("Service stopped.")</span>
} </pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
        "parental-control/internal/database"
)

// Config represents the complete application configuration
type Config struct {
        // Service configuration
        Service ServiceConfig `yaml:"service" json:"service"`
        
        // Database configuration
        Database database.Config `yaml:"database" json:"database"`
        
        // Logging configuration
        Logging LoggingConfig `yaml:"logging" json:"logging"`
        
        // Web interface configuration
        Web WebConfig `yaml:"web" json:"web"`
        
        // Security configuration
        Security SecurityConfig `yaml:"security" json:"security"`
        
        // Monitoring configuration
        Monitoring MonitoringConfig `yaml:"monitoring" json:"monitoring"`
}

// ServiceConfig holds service-specific settings
type ServiceConfig struct {
        // PIDFile path for storing process ID
        PIDFile string `yaml:"pid_file" json:"pid_file"`
        
        // ShutdownTimeout for graceful shutdown
        ShutdownTimeout time.Duration `yaml:"shutdown_timeout" json:"shutdown_timeout"`
        
        // HealthCheckInterval for periodic health checks
        HealthCheckInterval time.Duration `yaml:"health_check_interval" json:"health_check_interval"`
        
        // DataDirectory for application data
        DataDirectory string `yaml:"data_directory" json:"data_directory"`
        
        // ConfigDirectory for configuration files
        ConfigDirectory string `yaml:"config_directory" json:"config_directory"`
}

// LoggingConfig holds logging-specific settings
type LoggingConfig struct {
        // Level sets the logging level (DEBUG, INFO, WARN, ERROR, FATAL)
        Level string `yaml:"level" json:"level"`
        
        // Format sets the log format (json, text)
        Format string `yaml:"format" json:"format"`
        
        // Output sets the log output (stdout, stderr, file path)
        Output string `yaml:"output" json:"output"`
        
        // EnableTimestamp includes timestamps in logs
        EnableTimestamp bool `yaml:"enable_timestamp" json:"enable_timestamp"`
        
        // EnableCaller includes caller information in logs
        EnableCaller bool `yaml:"enable_caller" json:"enable_caller"`
}

// WebConfig holds web interface settings
type WebConfig struct {
        // Enabled indicates if web interface is enabled
        Enabled bool `yaml:"enabled" json:"enabled"`
        
        // Port for the web interface
        Port int `yaml:"port" json:"port"`
        
        // Host to bind the web interface to
        Host string `yaml:"host" json:"host"`
        
        // StaticDir for static web assets
        StaticDir string `yaml:"static_dir" json:"static_dir"`
        
        // TLSEnabled indicates if HTTPS is enabled
        TLSEnabled bool `yaml:"tls_enabled" json:"tls_enabled"`
        
        // TLSCertFile path to TLS certificate
        TLSCertFile string `yaml:"tls_cert_file" json:"tls_cert_file"`
        
        // TLSKeyFile path to TLS private key
        TLSKeyFile string `yaml:"tls_key_file" json:"tls_key_file"`
}

// SecurityConfig holds security-related settings
type SecurityConfig struct {
        // EnableAuth indicates if authentication is required
        EnableAuth bool `yaml:"enable_auth" json:"enable_auth"`
        
        // AdminPassword for admin access (should be hashed)
        AdminPassword string `yaml:"admin_password" json:"admin_password"`
        
        // SessionSecret for session management
        SessionSecret string `yaml:"session_secret" json:"session_secret"`
        
        // SessionTimeout for session expiration
        SessionTimeout time.Duration `yaml:"session_timeout" json:"session_timeout"`
        
        // MaxFailedAttempts before account lockout
        MaxFailedAttempts int `yaml:"max_failed_attempts" json:"max_failed_attempts"`
        
        // LockoutDuration for account lockout
        LockoutDuration time.Duration `yaml:"lockout_duration" json:"lockout_duration"`
}

// MonitoringConfig holds monitoring settings
type MonitoringConfig struct {
        // Enabled indicates if monitoring is enabled
        Enabled bool `yaml:"enabled" json:"enabled"`
        
        // MetricsPort for metrics endpoint
        MetricsPort int `yaml:"metrics_port" json:"metrics_port"`
        
        // MetricsPath for metrics endpoint
        MetricsPath string `yaml:"metrics_path" json:"metrics_path"`
        
        // HealthCheckPath for health check endpoint
        HealthCheckPath string `yaml:"health_check_path" json:"health_check_path"`
}

// Default returns a configuration with sensible defaults
func Default() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Service: ServiceConfig{
                        PIDFile:             "./data/parental-control.pid",
                        ShutdownTimeout:     30 * time.Second,
                        HealthCheckInterval: 30 * time.Second,
                        DataDirectory:       "./data",
                        ConfigDirectory:     "./config",
                },
                Database: database.DefaultConfig(),
                Logging: LoggingConfig{
                        Level:           "INFO",
                        Format:          "text",
                        Output:          "stdout",
                        EnableTimestamp: true,
                        EnableCaller:    false,
                },
                Web: WebConfig{
                        Enabled:     true,
                        Port:        8080,
                        Host:        "localhost",
                        StaticDir:   "./web/static",
                        TLSEnabled:  false,
                        TLSCertFile: "",
                        TLSKeyFile:  "",
                },
                Security: SecurityConfig{
                        EnableAuth:        false, // Disabled by default for easier setup
                        AdminPassword:     "",
                        SessionSecret:     "",
                        SessionTimeout:    24 * time.Hour,
                        MaxFailedAttempts: 5,
                        LockoutDuration:   15 * time.Minute,
                },
                Monitoring: MonitoringConfig{
                        Enabled:         true,
                        MetricsPort:     9090,
                        MetricsPath:     "/metrics",
                        HealthCheckPath: "/health",
                },
        }
}</span>

// LoadFromFile loads configuration from a YAML file
func LoadFromFile(path string) (*Config, error) <span class="cov8" title="1">{
        // Start with defaults
        config := Default()
        
        // Check if file exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return config, fmt.Errorf("configuration file not found: %s", path)
        }</span>
        
        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read configuration file: %w", err)
        }</span>
        
        // Parse YAML
        <span class="cov8" title="1">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse configuration file: %w", err)
        }</span>
        
        // Apply environment variable overrides
        <span class="cov8" title="1">if err := applyEnvironmentOverrides(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply environment overrides: %w", err)
        }</span>
        
        // Validate configuration
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>
        
        <span class="cov8" title="1">return config, nil</span>
}

// LoadFromEnvironment loads configuration from environment variables only
func LoadFromEnvironment() (*Config, error) <span class="cov8" title="1">{
        config := Default()
        
        if err := applyEnvironmentOverrides(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply environment overrides: %w", err)
        }</span>
        
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>
        
        <span class="cov8" title="1">return config, nil</span>
}

// applyEnvironmentOverrides applies environment variable overrides to the configuration
func applyEnvironmentOverrides(config *Config) error <span class="cov8" title="1">{
        // Service configuration
        if val := os.Getenv("PC_SERVICE_PID_FILE"); val != "" </span><span class="cov8" title="1">{
                config.Service.PIDFile = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_SERVICE_SHUTDOWN_TIMEOUT"); val != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(val); err == nil </span><span class="cov8" title="1">{
                        config.Service.ShutdownTimeout = duration
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_SERVICE_HEALTH_CHECK_INTERVAL"); val != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        config.Service.HealthCheckInterval = duration
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_SERVICE_DATA_DIRECTORY"); val != "" </span><span class="cov0" title="0">{
                config.Service.DataDirectory = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_SERVICE_CONFIG_DIRECTORY"); val != "" </span><span class="cov0" title="0">{
                config.Service.ConfigDirectory = val
        }</span>
        
        // Database configuration
        <span class="cov8" title="1">if val := os.Getenv("PC_DATABASE_PATH"); val != "" </span><span class="cov8" title="1">{
                config.Database.Path = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_DATABASE_MAX_OPEN_CONNS"); val != "" </span><span class="cov8" title="1">{
                if parsed, err := parseIntFromEnv(val); err == nil </span><span class="cov8" title="1">{
                        config.Database.MaxOpenConns = parsed
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_DATABASE_MAX_IDLE_CONNS"); val != "" </span><span class="cov0" title="0">{
                if parsed, err := parseIntFromEnv(val); err == nil </span><span class="cov0" title="0">{
                        config.Database.MaxIdleConns = parsed
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_DATABASE_ENABLE_WAL"); val != "" </span><span class="cov0" title="0">{
                config.Database.EnableWAL = strings.ToLower(val) == "true"
        }</span>
        
        // Logging configuration
        <span class="cov8" title="1">if val := os.Getenv("PC_LOGGING_LEVEL"); val != "" </span><span class="cov8" title="1">{
                config.Logging.Level = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_LOGGING_FORMAT"); val != "" </span><span class="cov8" title="1">{
                config.Logging.Format = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_LOGGING_OUTPUT"); val != "" </span><span class="cov0" title="0">{
                config.Logging.Output = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_LOGGING_ENABLE_TIMESTAMP"); val != "" </span><span class="cov0" title="0">{
                config.Logging.EnableTimestamp = strings.ToLower(val) == "true"
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_LOGGING_ENABLE_CALLER"); val != "" </span><span class="cov0" title="0">{
                config.Logging.EnableCaller = strings.ToLower(val) == "true"
        }</span>
        
        // Web configuration
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_ENABLED"); val != "" </span><span class="cov8" title="1">{
                config.Web.Enabled = strings.ToLower(val) == "true"
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_PORT"); val != "" </span><span class="cov8" title="1">{
                if parsed, err := parseIntFromEnv(val); err == nil </span><span class="cov8" title="1">{
                        config.Web.Port = parsed
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_HOST"); val != "" </span><span class="cov0" title="0">{
                config.Web.Host = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_STATIC_DIR"); val != "" </span><span class="cov0" title="0">{
                config.Web.StaticDir = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_TLS_ENABLED"); val != "" </span><span class="cov0" title="0">{
                config.Web.TLSEnabled = strings.ToLower(val) == "true"
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_TLS_CERT_FILE"); val != "" </span><span class="cov0" title="0">{
                config.Web.TLSCertFile = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_WEB_TLS_KEY_FILE"); val != "" </span><span class="cov0" title="0">{
                config.Web.TLSKeyFile = val
        }</span>
        
        // Security configuration
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_ENABLE_AUTH"); val != "" </span><span class="cov8" title="1">{
                config.Security.EnableAuth = strings.ToLower(val) == "true"
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_ADMIN_PASSWORD"); val != "" </span><span class="cov0" title="0">{
                config.Security.AdminPassword = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_SESSION_SECRET"); val != "" </span><span class="cov0" title="0">{
                config.Security.SessionSecret = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_SESSION_TIMEOUT"); val != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        config.Security.SessionTimeout = duration
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_MAX_FAILED_ATTEMPTS"); val != "" </span><span class="cov0" title="0">{
                if parsed, err := parseIntFromEnv(val); err == nil </span><span class="cov0" title="0">{
                        config.Security.MaxFailedAttempts = parsed
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_SECURITY_LOCKOUT_DURATION"); val != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        config.Security.LockoutDuration = duration
                }</span>
        }
        
        // Monitoring configuration
        <span class="cov8" title="1">if val := os.Getenv("PC_MONITORING_ENABLED"); val != "" </span><span class="cov8" title="1">{
                config.Monitoring.Enabled = strings.ToLower(val) == "true"
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_MONITORING_METRICS_PORT"); val != "" </span><span class="cov0" title="0">{
                if parsed, err := parseIntFromEnv(val); err == nil </span><span class="cov0" title="0">{
                        config.Monitoring.MetricsPort = parsed
                }</span>
        }
        <span class="cov8" title="1">if val := os.Getenv("PC_MONITORING_METRICS_PATH"); val != "" </span><span class="cov0" title="0">{
                config.Monitoring.MetricsPath = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("PC_MONITORING_HEALTH_CHECK_PATH"); val != "" </span><span class="cov0" title="0">{
                config.Monitoring.HealthCheckPath = val
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Validate validates the configuration for correctness
func (c *Config) Validate() error <span class="cov8" title="1">{
        var errors []string
        
        // Validate service configuration
        if c.Service.PIDFile == "" </span><span class="cov8" title="1">{
                errors = append(errors, "service.pid_file cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.Service.ShutdownTimeout &lt;= 0 </span><span class="cov8" title="1">{
                errors = append(errors, "service.shutdown_timeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.Service.HealthCheckInterval &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, "service.health_check_interval must be positive")
        }</span>
        <span class="cov8" title="1">if c.Service.DataDirectory == "" </span><span class="cov0" title="0">{
                errors = append(errors, "service.data_directory cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.Service.ConfigDirectory == "" </span><span class="cov0" title="0">{
                errors = append(errors, "service.config_directory cannot be empty")
        }</span>
        
        // Validate database configuration
        <span class="cov8" title="1">if c.Database.Path == "" </span><span class="cov0" title="0">{
                errors = append(errors, "database.path cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.Database.MaxOpenConns &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, "database.max_open_conns must be positive")
        }</span>
        <span class="cov8" title="1">if c.Database.MaxIdleConns &lt; 0 </span><span class="cov0" title="0">{
                errors = append(errors, "database.max_idle_conns cannot be negative")
        }</span>
        <span class="cov8" title="1">if c.Database.MaxIdleConns &gt; c.Database.MaxOpenConns </span><span class="cov0" title="0">{
                errors = append(errors, "database.max_idle_conns cannot exceed max_open_conns")
        }</span>
        
        // Validate logging configuration
        <span class="cov8" title="1">validLogLevels := map[string]bool{
                "DEBUG": true, "INFO": true, "WARN": true, "ERROR": true, "FATAL": true,
        }
        if !validLogLevels[strings.ToUpper(c.Logging.Level)] </span><span class="cov8" title="1">{
                errors = append(errors, "logging.level must be one of: DEBUG, INFO, WARN, ERROR, FATAL")
        }</span>
        
        <span class="cov8" title="1">validLogFormats := map[string]bool{"json": true, "text": true}
        if !validLogFormats[strings.ToLower(c.Logging.Format)] </span><span class="cov0" title="0">{
                errors = append(errors, "logging.format must be one of: json, text")
        }</span>
        
        // Validate web configuration
        <span class="cov8" title="1">if c.Web.Enabled </span><span class="cov8" title="1">{
                if c.Web.Port &lt;= 0 || c.Web.Port &gt; 65535 </span><span class="cov8" title="1">{
                        errors = append(errors, "web.port must be between 1 and 65535")
                }</span>
                <span class="cov8" title="1">if c.Web.Host == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "web.host cannot be empty when web interface is enabled")
                }</span>
                <span class="cov8" title="1">if c.Web.TLSEnabled </span><span class="cov8" title="1">{
                        if c.Web.TLSCertFile == "" </span><span class="cov8" title="1">{
                                errors = append(errors, "web.tls_cert_file is required when TLS is enabled")
                        }</span>
                        <span class="cov8" title="1">if c.Web.TLSKeyFile == "" </span><span class="cov8" title="1">{
                                errors = append(errors, "web.tls_key_file is required when TLS is enabled")
                        }</span>
                }
        }
        
        // Validate security configuration
        <span class="cov8" title="1">if c.Security.EnableAuth </span><span class="cov8" title="1">{
                if c.Security.AdminPassword == "" </span><span class="cov8" title="1">{
                        errors = append(errors, "security.admin_password is required when authentication is enabled")
                }</span>
                <span class="cov8" title="1">if c.Security.SessionSecret == "" </span><span class="cov8" title="1">{
                        errors = append(errors, "security.session_secret is required when authentication is enabled")
                }</span>
                <span class="cov8" title="1">if len(c.Security.SessionSecret) &lt; 32 </span><span class="cov8" title="1">{
                        errors = append(errors, "security.session_secret must be at least 32 characters")
                }</span>
        }
        <span class="cov8" title="1">if c.Security.SessionTimeout &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, "security.session_timeout must be positive")
        }</span>
        <span class="cov8" title="1">if c.Security.MaxFailedAttempts &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, "security.max_failed_attempts must be positive")
        }</span>
        <span class="cov8" title="1">if c.Security.LockoutDuration &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, "security.lockout_duration must be positive")
        }</span>
        
        // Validate monitoring configuration
        <span class="cov8" title="1">if c.Monitoring.Enabled </span><span class="cov8" title="1">{
                if c.Monitoring.MetricsPort &lt;= 0 || c.Monitoring.MetricsPort &gt; 65535 </span><span class="cov0" title="0">{
                        errors = append(errors, "monitoring.metrics_port must be between 1 and 65535")
                }</span>
                <span class="cov8" title="1">if c.Monitoring.MetricsPath == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "monitoring.metrics_path cannot be empty when monitoring is enabled")
                }</span>
                <span class="cov8" title="1">if c.Monitoring.HealthCheckPath == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "monitoring.health_check_path cannot be empty when monitoring is enabled")
                }</span>
                // Check for port conflicts
                <span class="cov8" title="1">if c.Web.Enabled &amp;&amp; c.Web.Port == c.Monitoring.MetricsPort </span><span class="cov8" title="1">{
                        errors = append(errors, "web.port and monitoring.metrics_port cannot be the same")
                }</span>
        }
        
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("validation errors: %s", strings.Join(errors, "; "))
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// SaveToFile saves the configuration to a YAML file
func (c *Config) SaveToFile(path string) error <span class="cov8" title="1">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>
        
        // Marshal to YAML
        <span class="cov8" title="1">data, err := yaml.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal configuration: %w", err)
        }</span>
        
        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write configuration file: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Clone creates a deep copy of the configuration
func (c *Config) Clone() *Config <span class="cov8" title="1">{
        clone := *c
        return &amp;clone
}</span>

// GetServiceConfig returns the service configuration
func (c *Config) GetServiceConfig() ServiceConfig <span class="cov8" title="1">{
        return c.Service
}</span>

// GetDatabaseConfig returns the database configuration
func (c *Config) GetDatabaseConfig() database.Config <span class="cov8" title="1">{
        return c.Database
}</span>

// GetLoggingConfig returns the logging configuration
func (c *Config) GetLoggingConfig() LoggingConfig <span class="cov8" title="1">{
        return c.Logging
}</span>

// GetWebConfig returns the web configuration
func (c *Config) GetWebConfig() WebConfig <span class="cov8" title="1">{
        return c.Web
}</span>

// GetSecurityConfig returns the security configuration
func (c *Config) GetSecurityConfig() SecurityConfig <span class="cov8" title="1">{
        return c.Security
}</span>

// GetMonitoringConfig returns the monitoring configuration
func (c *Config) GetMonitoringConfig() MonitoringConfig <span class="cov8" title="1">{
        return c.Monitoring
}</span>

// parseIntFromEnv parses an integer from environment variable string
func parseIntFromEnv(val string) (int, error) <span class="cov8" title="1">{
        if val == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty value")
        }</span>
        
        // Parse as integer, reject if it contains decimal points
        <span class="cov8" title="1">if strings.Contains(val, ".") </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid integer (contains decimal): %s", val)
        }</span>
        
        // Simple integer parsing
        <span class="cov8" title="1">var result int
        if _, err := fmt.Sscanf(val, "%d", &amp;result); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid integer: %s", val)
        }</span>
        
        <span class="cov8" title="1">return result, nil</span>
} </pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "database/sql"
        "embed"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "parental-control/internal/logging"

        // SQLite driver
        _ "github.com/mattn/go-sqlite3"
)

//go:embed migrations/*.sql
var migrationsFS embed.FS

// DB wraps the sql.DB connection with additional functionality
type DB struct {
        conn *sql.DB
        path string
}

// Config holds database configuration
type Config struct {
        // Path to the database file
        Path string
        // Maximum number of open connections
        MaxOpenConns int
        // Maximum number of idle connections
        MaxIdleConns int
        // Connection maximum lifetime
        ConnMaxLifetime time.Duration
        // Enable WAL mode for better concurrency
        EnableWAL bool
        // Timeout for database operations
        Timeout time.Duration
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                Path:            "./data/parental-control.db",
                MaxOpenConns:    10,
                MaxIdleConns:    5,
                ConnMaxLifetime: time.Hour,
                EnableWAL:       true,
                Timeout:         30 * time.Second,
        }
}</span>

// New creates a new database connection with the given configuration
func New(config Config) (*DB, error) <span class="cov8" title="1">{
        // Ensure the directory exists
        dir := filepath.Dir(config.Path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>

        // Build connection string with options
        <span class="cov8" title="1">dsn := config.Path
        if config.EnableWAL </span><span class="cov8" title="1">{
                dsn += "?_journal_mode=WAL&amp;_synchronous=NORMAL&amp;_cache_size=1000&amp;_foreign_keys=1"
        }</span> else<span class="cov0" title="0"> {
                dsn += "?_foreign_keys=1"
        }</span>

        // Open database connection
        <span class="cov8" title="1">conn, err := sql.Open("sqlite3", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov8" title="1">conn.SetMaxOpenConns(config.MaxOpenConns)
        conn.SetMaxIdleConns(config.MaxIdleConns)
        conn.SetConnMaxLifetime(config.ConnMaxLifetime)

        db := &amp;DB{
                conn: conn,
                path: config.Path,
        }

        // Test the connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("database connection test failed: %w", err)
        }</span>

        <span class="cov8" title="1">logging.Info("Database connection established", logging.String("path", config.Path))

        return db, nil</span>
}

// Ping tests the database connection
func (db *DB) Ping() error <span class="cov8" title="1">{
        return db.conn.Ping()
}</span>

// Close closes the database connection
func (db *DB) Close() error <span class="cov8" title="1">{
        if db.conn != nil </span><span class="cov8" title="1">{
                logging.Info("Closing database connection")
                return db.conn.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Connection returns the underlying sql.DB connection
func (db *DB) Connection() *sql.DB <span class="cov8" title="1">{
        return db.conn
}</span>

// Path returns the database file path
func (db *DB) Path() string <span class="cov8" title="1">{
        return db.path
}</span>

// InitializeSchema runs all pending migrations to set up the database schema
func (db *DB) InitializeSchema() error <span class="cov8" title="1">{
        logging.Info("Initializing database schema")

        // Get current schema version
        currentVersion, err := db.getCurrentSchemaVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current schema version: %w", err)
        }</span>

        // Apply migrations
        <span class="cov8" title="1">if err := db.applyMigrations(currentVersion); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply migrations: %w", err)
        }</span>

        <span class="cov8" title="1">logging.Info("Database schema initialization complete")
        return nil</span>
}

// getCurrentSchemaVersion returns the current schema version
func (db *DB) getCurrentSchemaVersion() (int, error) <span class="cov8" title="1">{
        // Check if schema_versions table exists
        var exists bool
        err := db.conn.QueryRow(`
                SELECT COUNT(*) &gt; 0 
                FROM sqlite_master 
                WHERE type='table' AND name='schema_versions'
        `).Scan(&amp;exists)
        
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return 0, nil // No schema version table means version 0
        }</span>

        // Get the latest version
        <span class="cov8" title="1">var version int
        err = db.conn.QueryRow("SELECT MAX(version) FROM schema_versions").Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return version, nil</span>
}

// applyMigrations applies all migrations newer than the current version
func (db *DB) applyMigrations(currentVersion int) error <span class="cov8" title="1">{
        // Read migration files
        entries, err := migrationsFS.ReadDir("migrations")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read migrations directory: %w", err)
        }</span>

        // Apply each migration file
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">filename := entry.Name()
                
                // Read migration content
                content, err := migrationsFS.ReadFile("migrations/" + filename)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read migration file %s: %w", filename, err)
                }</span>

                <span class="cov8" title="1">logging.Info("Applying migration", logging.String("file", filename))

                // Execute migration in a transaction
                tx, err := db.conn.Begin()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start transaction for migration %s: %w", filename, err)
                }</span>

                <span class="cov8" title="1">if _, err := tx.Exec(string(content)); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("failed to execute migration %s: %w", filename, err)
                }</span>

                <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to commit migration %s: %w", filename, err)
                }</span>

                <span class="cov8" title="1">logging.Info("Migration applied successfully", logging.String("file", filename))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// HealthCheck performs a comprehensive health check of the database
func (db *DB) HealthCheck() error <span class="cov8" title="1">{
        // Test basic connectivity
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ping failed: %w", err)
        }</span>

        // Test a simple query
        <span class="cov8" title="1">var result int
        if err := db.conn.QueryRow("SELECT 1").Scan(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("test query failed: %w", err)
        }</span>

        // Check that required tables exist
        <span class="cov8" title="1">requiredTables := []string{
                "config", "lists", "list_entries", "time_rules", 
                "quota_rules", "quota_usage", "audit_log", "schema_versions",
        }

        for _, table := range requiredTables </span><span class="cov8" title="1">{
                var exists bool
                err := db.conn.QueryRow(`
                        SELECT COUNT(*) &gt; 0 
                        FROM sqlite_master 
                        WHERE type='table' AND name=?
                `, table).Scan(&amp;exists)
                
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check table %s: %w", table, err)
                }</span>
                
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("required table %s does not exist", table)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetStats returns database statistics
func (db *DB) GetStats() (map[string]interface{}, error) <span class="cov8" title="1">{
        stats := make(map[string]interface{})
        
        // Connection pool stats
        dbStats := db.conn.Stats()
        stats["open_connections"] = dbStats.OpenConnections
        stats["in_use"] = dbStats.InUse
        stats["idle"] = dbStats.Idle
        stats["wait_count"] = dbStats.WaitCount
        stats["wait_duration"] = dbStats.WaitDuration.String()
        stats["max_idle_closed"] = dbStats.MaxIdleClosed
        stats["max_lifetime_closed"] = dbStats.MaxLifetimeClosed

        // Database file info
        if info, err := os.Stat(db.path); err == nil </span><span class="cov8" title="1">{
                stats["file_size"] = info.Size()
                stats["modified_time"] = info.ModTime()
        }</span>

        // Schema version
        <span class="cov8" title="1">if version, err := db.getCurrentSchemaVersion(); err == nil </span><span class="cov8" title="1">{
                stats["schema_version"] = version
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
} </pre>
		
		<pre class="file" id="file3" style="display: none">package logging

import (
        "fmt"
        "io"
        "log"
        "os"
        "time"
)

// LogLevel represents the severity of log messages
type LogLevel int

const (
        // DEBUG level for debugging information
        DEBUG LogLevel = iota
        // INFO level for informational messages
        INFO
        // WARN level for warning messages
        WARN
        // ERROR level for error messages
        ERROR
        // FATAL level for fatal errors that cause program termination
        FATAL
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DEBUG:<span class="cov8" title="1">
                return "DEBUG"</span>
        case INFO:<span class="cov8" title="1">
                return "INFO"</span>
        case WARN:<span class="cov8" title="1">
                return "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                return "ERROR"</span>
        case FATAL:<span class="cov8" title="1">
                return "FATAL"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// Logger provides structured logging functionality
type Logger struct {
        level  LogLevel
        logger *log.Logger
}

// Config holds the logger configuration
type Config struct {
        Level  LogLevel
        Output io.Writer
}

// New creates a new logger with the given configuration
func New(config Config) *Logger <span class="cov8" title="1">{
        if config.Output == nil </span><span class="cov0" title="0">{
                config.Output = os.Stdout
        }</span>

        <span class="cov8" title="1">return &amp;Logger{
                level:  config.Level,
                logger: log.New(config.Output, "", 0), // No default flags, we'll format ourselves
        }</span>
}

// NewDefault creates a logger with default configuration
func NewDefault() *Logger <span class="cov8" title="1">{
        return New(Config{
                Level:  INFO,
                Output: os.Stdout,
        })
}</span>

// SetLevel changes the minimum log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.level = level
}</span>

// Debug logs a debug message
func (l *Logger) Debug(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= DEBUG </span><span class="cov8" title="1">{
                l.log(DEBUG, msg, fields...)
        }</span>
}

// Info logs an info message
func (l *Logger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= INFO </span><span class="cov8" title="1">{
                l.log(INFO, msg, fields...)
        }</span>
}

// Warn logs a warning message
func (l *Logger) Warn(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= WARN </span><span class="cov8" title="1">{
                l.log(WARN, msg, fields...)
        }</span>
}

// Error logs an error message
func (l *Logger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
        if l.level &lt;= ERROR </span><span class="cov8" title="1">{
                l.log(ERROR, msg, fields...)
        }</span>
}

// Fatal logs a fatal message and exits the program
func (l *Logger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(FATAL, msg, fields...)
        os.Exit(1)
}</span>

// log formats and writes the log message
func (l *Logger) log(level LogLevel, msg string, fields ...Field) <span class="cov8" title="1">{
        timestamp := time.Now().Format("2006-01-02T15:04:05.000Z07:00")
        
        logLine := timestamp + " [" + level.String() + "] " + msg
        
        // Append fields if any
        for _, field := range fields </span><span class="cov8" title="1">{
                logLine += " " + field.String()
        }</span>
        
        <span class="cov8" title="1">l.logger.Println(logLine)</span>
}

// Field represents a structured log field
type Field struct {
        Key   string
        Value interface{}
}

// String returns the string representation of the field
func (f Field) String() string <span class="cov8" title="1">{
        return f.Key + "=" + formatValue(f.Value)
}</span>

// String creates a string field
func String(key, value string) Field <span class="cov8" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Int creates an integer field
func Int(key string, value int) Field <span class="cov8" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Bool creates a boolean field
func Bool(key string, value bool) Field <span class="cov8" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Err creates an error field
func Err(err error) Field <span class="cov0" title="0">{
        return Field{Key: "error", Value: err.Error()}
}</span>

// formatValue formats a field value for logging
func formatValue(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return "\"" + v + "\""</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprint(v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprint(v)</span>
        case float32, float64:<span class="cov8" title="1">
                return fmt.Sprint(v)</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov8" title="1">return "false"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprint(v)</span>
        }
}

// Global logger instance
var globalLogger = NewDefault()

// SetGlobalLogger sets the global logger instance
func SetGlobalLogger(logger *Logger) <span class="cov8" title="1">{
        globalLogger = logger
}</span>

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *Logger <span class="cov8" title="1">{
        return globalLogger
}</span>

// Global logging functions
func Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        globalLogger.Debug(msg, fields...)
}</span>

func Info(msg string, fields ...Field) <span class="cov8" title="1">{
        globalLogger.Info(msg, fields...)
}</span>

func Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        globalLogger.Warn(msg, fields...)
}</span>

func Error(msg string, fields ...Field) <span class="cov0" title="0">{
        globalLogger.Error(msg, fields...)
}</span>

func Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        globalLogger.Fatal(msg, fields...)
}</span> </pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "time"
)

// Config represents a configuration key-value pair
type Config struct {
        ID          int       `json:"id" db:"id"`
        Key         string    `json:"key" db:"key" validate:"required,max=255"`
        Value       string    `json:"value" db:"value" validate:"required"`
        Description string    `json:"description" db:"description"`
        CreatedAt   time.Time `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}

// ListType represents the type of list (whitelist or blacklist)
type ListType string

const (
        ListTypeWhitelist ListType = "whitelist"
        ListTypeBlacklist ListType = "blacklist"
)

// List represents a whitelist or blacklist containing entries
type List struct {
        ID          int         `json:"id" db:"id"`
        Name        string      `json:"name" db:"name" validate:"required,max=255"`
        Type        ListType    `json:"type" db:"type" validate:"required,oneof=whitelist blacklist"`
        Description string      `json:"description" db:"description"`
        Enabled     bool        `json:"enabled" db:"enabled"`
        CreatedAt   time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time   `json:"updated_at" db:"updated_at"`
        Entries     []ListEntry `json:"entries,omitempty" db:"-"`
}

// EntryType represents the type of list entry (executable or URL)
type EntryType string

const (
        EntryTypeExecutable EntryType = "executable"
        EntryTypeURL        EntryType = "url"
)

// PatternType represents how to match the pattern
type PatternType string

const (
        PatternTypeExact    PatternType = "exact"
        PatternTypeWildcard PatternType = "wildcard"
        PatternTypeDomain   PatternType = "domain"
)

// ListEntry represents an entry in a list (executable or URL)
type ListEntry struct {
        ID          int         `json:"id" db:"id"`
        ListID      int         `json:"list_id" db:"list_id" validate:"required"`
        EntryType   EntryType   `json:"entry_type" db:"entry_type" validate:"required,oneof=executable url"`
        Pattern     string      `json:"pattern" db:"pattern" validate:"required,max=1000"`
        PatternType PatternType `json:"pattern_type" db:"pattern_type" validate:"required,oneof=exact wildcard domain"`
        Description string      `json:"description" db:"description"`
        Enabled     bool        `json:"enabled" db:"enabled"`
        CreatedAt   time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time   `json:"updated_at" db:"updated_at"`
}

// RuleType represents the type of time rule
type RuleType string

const (
        RuleTypeAllowDuring RuleType = "allow_during"
        RuleTypeBlockDuring RuleType = "block_during"
)

// TimeRule represents a time-based rule for when lists are active
type TimeRule struct {
        ID         int      `json:"id" db:"id"`
        ListID     int      `json:"list_id" db:"list_id" validate:"required"`
        Name       string   `json:"name" db:"name" validate:"required,max=255"`
        RuleType   RuleType `json:"rule_type" db:"rule_type" validate:"required,oneof=allow_during block_during"`
        DaysOfWeek []int    `json:"days_of_week" db:"days_of_week" validate:"required,dive,min=0,max=6"`
        StartTime  string   `json:"start_time" db:"start_time" validate:"required"`
        EndTime    string   `json:"end_time" db:"end_time" validate:"required"`
        Enabled    bool     `json:"enabled" db:"enabled"`
        CreatedAt  time.Time `json:"created_at" db:"created_at"`
        UpdatedAt  time.Time `json:"updated_at" db:"updated_at"`
}

// MarshalDaysOfWeek converts the days of week slice to JSON for database storage
func (tr *TimeRule) MarshalDaysOfWeek() (string, error) <span class="cov8" title="1">{
        data, err := json.Marshal(tr.DaysOfWeek)
        return string(data), err
}</span>

// UnmarshalDaysOfWeek converts the JSON string from database to days of week slice
func (tr *TimeRule) UnmarshalDaysOfWeek(data string) error <span class="cov8" title="1">{
        return json.Unmarshal([]byte(data), &amp;tr.DaysOfWeek)
}</span>

// ValidateTimeFormat validates that the time string is in HH:MM format
func ValidateTimeFormat(timeStr string) error <span class="cov8" title="1">{
        _, err := time.Parse("15:04", timeStr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid time format, expected HH:MM")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// QuotaType represents the type of quota (daily, weekly, monthly)
type QuotaType string

const (
        QuotaTypeDaily   QuotaType = "daily"
        QuotaTypeWeekly  QuotaType = "weekly"
        QuotaTypeMonthly QuotaType = "monthly"
)

// QuotaRule represents a duration-based limit rule
type QuotaRule struct {
        ID           int       `json:"id" db:"id"`
        ListID       int       `json:"list_id" db:"list_id" validate:"required"`
        Name         string    `json:"name" db:"name" validate:"required,max=255"`
        QuotaType    QuotaType `json:"quota_type" db:"quota_type" validate:"required,oneof=daily weekly monthly"`
        LimitSeconds int       `json:"limit_seconds" db:"limit_seconds" validate:"required,min=1"`
        Enabled      bool      `json:"enabled" db:"enabled"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}

// GetLimitDuration returns the limit as a time.Duration
func (qr *QuotaRule) GetLimitDuration() time.Duration <span class="cov8" title="1">{
        return time.Duration(qr.LimitSeconds) * time.Second
}</span>

// QuotaUsage tracks usage against quota rules
type QuotaUsage struct {
        ID           int       `json:"id" db:"id"`
        QuotaRuleID  int       `json:"quota_rule_id" db:"quota_rule_id" validate:"required"`
        PeriodStart  time.Time `json:"period_start" db:"period_start" validate:"required"`
        PeriodEnd    time.Time `json:"period_end" db:"period_end" validate:"required"`
        UsedSeconds  int       `json:"used_seconds" db:"used_seconds"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}

// GetUsedDuration returns the used time as a time.Duration
func (qu *QuotaUsage) GetUsedDuration() time.Duration <span class="cov8" title="1">{
        return time.Duration(qu.UsedSeconds) * time.Second
}</span>

// RemainingSeconds returns the remaining seconds in the quota
func (qu *QuotaUsage) RemainingSeconds(limitSeconds int) int <span class="cov8" title="1">{
        remaining := limitSeconds - qu.UsedSeconds
        if remaining &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return remaining</span>
}

// ActionType represents the action taken (allow or block)
type ActionType string

const (
        ActionTypeAllow ActionType = "allow"
        ActionTypeBlock ActionType = "block"
)

// TargetType represents the type of target (executable or URL)
type TargetType string

const (
        TargetTypeExecutable TargetType = "executable"
        TargetTypeURL        TargetType = "url"
)

// AuditLog represents an audit log entry
type AuditLog struct {
        ID          int        `json:"id" db:"id"`
        Timestamp   time.Time  `json:"timestamp" db:"timestamp"`
        EventType   string     `json:"event_type" db:"event_type" validate:"required,max=100"`
        TargetType  TargetType `json:"target_type" db:"target_type" validate:"required,oneof=executable url"`
        TargetValue string     `json:"target_value" db:"target_value" validate:"required,max=1000"`
        Action      ActionType `json:"action" db:"action" validate:"required,oneof=allow block"`
        RuleType    string     `json:"rule_type" db:"rule_type"`
        RuleID      *int       `json:"rule_id" db:"rule_id"`
        Details     string     `json:"details" db:"details"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
}

// GetDetailsMap parses the details JSON into a map
func (al *AuditLog) GetDetailsMap() (map[string]interface{}, error) <span class="cov8" title="1">{
        if al.Details == "" </span><span class="cov8" title="1">{
                return make(map[string]interface{}), nil
        }</span>
        
        <span class="cov8" title="1">var details map[string]interface{}
        err := json.Unmarshal([]byte(al.Details), &amp;details)
        return details, err</span>
}

// SetDetailsMap converts a map to JSON and stores it in Details
func (al *AuditLog) SetDetailsMap(details map[string]interface{}) error <span class="cov8" title="1">{
        if details == nil </span><span class="cov8" title="1">{
                al.Details = ""
                return nil
        }</span>
        
        <span class="cov8" title="1">data, err := json.Marshal(details)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">al.Details = string(data)
        return nil</span>
}

// SchemaVersion represents a database schema version
type SchemaVersion struct {
        Version     int       `json:"version" db:"version"`
        AppliedAt   time.Time `json:"applied_at" db:"applied_at"`
        Description string    `json:"description" db:"description"`
}

// ValidationError represents a validation error for a specific field
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// Error implements the error interface
func (ve ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error on field '%s': %s", ve.Field, ve.Message)
}</span>

// ValidationErrors represents multiple validation errors
type ValidationErrors []ValidationError

// Error implements the error interface
func (ves ValidationErrors) Error() string <span class="cov8" title="1">{
        if len(ves) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">if len(ves) == 1 </span><span class="cov8" title="1">{
                return ves[0].Error()
        }</span>
        
        <span class="cov8" title="1">return fmt.Sprintf("multiple validation errors: %d errors", len(ves))</span>
}

// HasErrors returns true if there are validation errors
func (ves ValidationErrors) HasErrors() bool <span class="cov8" title="1">{
        return len(ves) &gt; 0
}</span>

// Add adds a validation error
func (ves *ValidationErrors) Add(field, message string) <span class="cov8" title="1">{
        *ves = append(*ves, ValidationError{Field: field, Message: message})
}</span>

// Summary statistics for the dashboard
type DashboardStats struct {
        TotalLists      int `json:"total_lists"`
        TotalEntries    int `json:"total_entries"`
        ActiveRules     int `json:"active_rules"`
        TodayBlocks     int `json:"today_blocks"`
        TodayAllows     int `json:"today_allows"`
        QuotasNearLimit int `json:"quotas_near_limit"`
} </pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "context"
        "time"
)

// Repository interfaces define the contract for data access

// ConfigRepository handles configuration data access
type ConfigRepository interface {
        Get(ctx context.Context, key string) (*Config, error)
        Set(ctx context.Context, key, value string) error
        GetAll(ctx context.Context) ([]Config, error)
        Delete(ctx context.Context, key string) error
        Update(ctx context.Context, config *Config) error
}

// ListRepository handles list data access
type ListRepository interface {
        Create(ctx context.Context, list *List) error
        GetByID(ctx context.Context, id int) (*List, error)
        GetByName(ctx context.Context, name string) (*List, error)
        GetAll(ctx context.Context) ([]List, error)
        GetByType(ctx context.Context, listType ListType) ([]List, error)
        GetEnabled(ctx context.Context) ([]List, error)
        Update(ctx context.Context, list *List) error
        Delete(ctx context.Context, id int) error
        Count(ctx context.Context) (int, error)
}

// ListEntryRepository handles list entry data access
type ListEntryRepository interface {
        Create(ctx context.Context, entry *ListEntry) error
        GetByID(ctx context.Context, id int) (*ListEntry, error)
        GetByListID(ctx context.Context, listID int) ([]ListEntry, error)
        GetByPattern(ctx context.Context, pattern string, entryType EntryType) ([]ListEntry, error)
        GetEnabled(ctx context.Context) ([]ListEntry, error)
        Update(ctx context.Context, entry *ListEntry) error
        Delete(ctx context.Context, id int) error
        DeleteByListID(ctx context.Context, listID int) error
        Count(ctx context.Context) (int, error)
        CountByListID(ctx context.Context, listID int) (int, error)
}

// TimeRuleRepository handles time rule data access
type TimeRuleRepository interface {
        Create(ctx context.Context, rule *TimeRule) error
        GetByID(ctx context.Context, id int) (*TimeRule, error)
        GetByListID(ctx context.Context, listID int) ([]TimeRule, error)
        GetEnabled(ctx context.Context) ([]TimeRule, error)
        GetActiveRules(ctx context.Context, now time.Time) ([]TimeRule, error)
        Update(ctx context.Context, rule *TimeRule) error
        Delete(ctx context.Context, id int) error
        DeleteByListID(ctx context.Context, listID int) error
        Count(ctx context.Context) (int, error)
}

// QuotaRuleRepository handles quota rule data access
type QuotaRuleRepository interface {
        Create(ctx context.Context, rule *QuotaRule) error
        GetByID(ctx context.Context, id int) (*QuotaRule, error)
        GetByListID(ctx context.Context, listID int) ([]QuotaRule, error)
        GetEnabled(ctx context.Context) ([]QuotaRule, error)
        Update(ctx context.Context, rule *QuotaRule) error
        Delete(ctx context.Context, id int) error
        DeleteByListID(ctx context.Context, listID int) error
        Count(ctx context.Context) (int, error)
}

// QuotaUsageRepository handles quota usage tracking
type QuotaUsageRepository interface {
        Create(ctx context.Context, usage *QuotaUsage) error
        GetByID(ctx context.Context, id int) (*QuotaUsage, error)
        GetByQuotaRuleID(ctx context.Context, quotaRuleID int) ([]QuotaUsage, error)
        GetCurrentUsage(ctx context.Context, quotaRuleID int, now time.Time) (*QuotaUsage, error)
        UpdateUsage(ctx context.Context, quotaRuleID int, additionalSeconds int, now time.Time) error
        GetUsageInPeriod(ctx context.Context, quotaRuleID int, start, end time.Time) (*QuotaUsage, error)
        CleanupExpiredUsage(ctx context.Context, before time.Time) error
        Update(ctx context.Context, usage *QuotaUsage) error
        Delete(ctx context.Context, id int) error
}

// AuditLogRepository handles audit log data access
type AuditLogRepository interface {
        Create(ctx context.Context, log *AuditLog) error
        GetByID(ctx context.Context, id int) (*AuditLog, error)
        GetAll(ctx context.Context, limit, offset int) ([]AuditLog, error)
        GetByTimeRange(ctx context.Context, start, end time.Time, limit, offset int) ([]AuditLog, error)
        GetByAction(ctx context.Context, action ActionType, limit, offset int) ([]AuditLog, error)
        GetByTargetType(ctx context.Context, targetType TargetType, limit, offset int) ([]AuditLog, error)
        GetTodayStats(ctx context.Context) (allows int, blocks int, err error)
        CleanupOldLogs(ctx context.Context, before time.Time) error
        Count(ctx context.Context) (int, error)
        CountByTimeRange(ctx context.Context, start, end time.Time) (int, error)
}

// SchemaVersionRepository handles schema version tracking
type SchemaVersionRepository interface {
        GetLatestVersion(ctx context.Context) (*SchemaVersion, error)
        GetAll(ctx context.Context) ([]SchemaVersion, error)
        Create(ctx context.Context, version *SchemaVersion) error
}

// DashboardRepository provides aggregated data for dashboard
type DashboardRepository interface {
        GetStats(ctx context.Context) (*DashboardStats, error)
        GetQuotasNearLimit(ctx context.Context, threshold float64) ([]QuotaUsage, error)
}

// RepositoryManager aggregates all repositories
type RepositoryManager struct {
        Config       ConfigRepository
        List         ListRepository
        ListEntry    ListEntryRepository
        TimeRule     TimeRuleRepository
        QuotaRule    QuotaRuleRepository
        QuotaUsage   QuotaUsageRepository
        AuditLog     AuditLogRepository
        SchemaVersion SchemaVersionRepository
        Dashboard    DashboardRepository
}

// SearchFilters for advanced queries
type SearchFilters struct {
        Enabled   *bool
        ListType  *ListType
        EntryType *EntryType
        StartDate *time.Time
        EndDate   *time.Time
        Limit     int
        Offset    int
        Search    string
}

// DefaultSearchFilters returns filters with sensible defaults
func DefaultSearchFilters() SearchFilters <span class="cov8" title="1">{
        return SearchFilters{
                Limit:  50,
                Offset: 0,
        }
}</span> </pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "strconv"
        "sync"
        "syscall"
        "time"

        "parental-control/internal/database"
        "parental-control/internal/logging"
        "parental-control/internal/models"
)

// ServiceState represents the current state of the service
type ServiceState int

const (
        // StateStopped indicates the service is not running
        StateStopped ServiceState = iota
        // StateStarting indicates the service is in the process of starting
        StateStarting
        // StateRunning indicates the service is running normally
        StateRunning
        // StateStopping indicates the service is in the process of stopping
        StateStopping
        // StateError indicates the service is in an error state
        StateError
)

// String returns the string representation of the service state
func (s ServiceState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateStopped:<span class="cov8" title="1">
                return "stopped"</span>
        case StateStarting:<span class="cov8" title="1">
                return "starting"</span>
        case StateRunning:<span class="cov8" title="1">
                return "running"</span>
        case StateStopping:<span class="cov8" title="1">
                return "stopping"</span>
        case StateError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Config holds the service configuration
type Config struct {
        // PIDFile path for storing process ID
        PIDFile string
        // ShutdownTimeout for graceful shutdown
        ShutdownTimeout time.Duration
        // DatabaseConfig for database connection
        DatabaseConfig database.Config
        // HealthCheckInterval for periodic health checks
        HealthCheckInterval time.Duration
}

// DefaultConfig returns a service configuration with sensible defaults
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                PIDFile:             "./data/parental-control.pid",
                ShutdownTimeout:     30 * time.Second,
                DatabaseConfig:      database.DefaultConfig(),
                HealthCheckInterval: 30 * time.Second,
        }
}</span>

// Service manages the application lifecycle
type Service struct {
        config    Config
        state     ServiceState
        stateMu   sync.RWMutex
        db        *database.DB
        repos     *models.RepositoryManager
        ctx       context.Context
        cancel    context.CancelFunc
        startTime time.Time
        errors    []error
        errorsMu  sync.RWMutex
}

// New creates a new service instance with the given configuration
func New(config Config) *Service <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        
        return &amp;Service{
                config: config,
                state:  StateStopped,
                ctx:    ctx,
                cancel: cancel,
                errors: make([]error, 0),
        }
}</span>

// Start initializes and starts the service
func (s *Service) Start() error <span class="cov8" title="1">{
        s.setState(StateStarting)
        s.startTime = time.Now()
        
        logging.Info("Starting Parental Control Service")
        
        // Initialize components in order
        if err := s.initializeDatabase(); err != nil </span><span class="cov8" title="1">{
                s.addError(fmt.Errorf("database initialization failed: %w", err))
                s.setState(StateError)
                return err
        }</span>
        
        <span class="cov8" title="1">if err := s.initializeRepositories(); err != nil </span><span class="cov0" title="0">{
                s.addError(fmt.Errorf("repository initialization failed: %w", err))
                s.setState(StateError)
                return err
        }</span>
        
        <span class="cov8" title="1">if err := s.writePIDFile(); err != nil </span><span class="cov0" title="0">{
                s.addError(fmt.Errorf("PID file creation failed: %w", err))
                s.setState(StateError)
                return err
        }</span>
        
        // Set up signal handling
        <span class="cov8" title="1">s.setupSignalHandling()
        
        // Start health check routine
        go s.healthCheckRoutine()
        
        s.setState(StateRunning)
        logging.Info("Service started successfully", 
                logging.String("pid_file", s.config.PIDFile),
                logging.String("startup_time", time.Since(s.startTime).String()))
        
        return nil</span>
}

// Stop gracefully shuts down the service
func (s *Service) Stop() error <span class="cov8" title="1">{
        if s.getState() == StateStopped </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">s.setState(StateStopping)
        logging.Info("Stopping Parental Control Service")
        
        // Cancel context to signal all goroutines to stop
        s.cancel()
        
        // Create a timeout context for shutdown
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), s.config.ShutdownTimeout)
        defer shutdownCancel()
        
        // Cleanup in reverse order of initialization
        s.cleanup(shutdownCtx)
        
        s.setState(StateStopped)
        logging.Info("Service stopped successfully")
        
        return nil</span>
}

// Restart stops and then starts the service
func (s *Service) Restart() error <span class="cov8" title="1">{
        logging.Info("Restarting service")
        
        if err := s.Stop(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop service during restart: %w", err)
        }</span>
        
        // Brief pause before restart
        <span class="cov8" title="1">time.Sleep(1 * time.Second)
        
        return s.Start()</span>
}

// GetState returns the current service state
func (s *Service) GetState() ServiceState <span class="cov8" title="1">{
        return s.getState()
}</span>

// GetStatus returns detailed status information
func (s *Service) GetStatus() map[string]interface{} <span class="cov8" title="1">{
        s.stateMu.RLock()
        s.errorsMu.RLock()
        defer s.stateMu.RUnlock()
        defer s.errorsMu.RUnlock()
        
        status := map[string]interface{}{
                "state":      s.state.String(),
                "start_time": s.startTime,
                "uptime":     time.Since(s.startTime).String(),
                "pid":        os.Getpid(),
                "errors":     len(s.errors),
        }
        
        if s.db != nil </span><span class="cov8" title="1">{
                dbStats, err := s.db.GetStats()
                if err == nil </span><span class="cov8" title="1">{
                        status["database"] = dbStats
                }</span>
        }
        
        <span class="cov8" title="1">return status</span>
}

// IsHealthy performs a health check and returns the result
func (s *Service) IsHealthy() error <span class="cov8" title="1">{
        if s.getState() != StateRunning </span><span class="cov8" title="1">{
                return fmt.Errorf("service is not running (state: %s)", s.getState())
        }</span>
        
        // Check database health
        <span class="cov8" title="1">if s.db != nil </span><span class="cov8" title="1">{
                if err := s.db.HealthCheck(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("database health check failed: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// Wait blocks until the service stops
func (s *Service) Wait() <span class="cov8" title="1">{
        &lt;-s.ctx.Done()
}</span>

// initializeDatabase sets up the database connection and schema
func (s *Service) initializeDatabase() error <span class="cov8" title="1">{
        logging.Info("Initializing database connection")
        
        db, err := database.New(s.config.DatabaseConfig)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create database connection: %w", err)
        }</span>
        
        <span class="cov8" title="1">if err := db.InitializeSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return fmt.Errorf("failed to initialize database schema: %w", err)
        }</span>
        
        <span class="cov8" title="1">s.db = db
        logging.Info("Database initialized successfully")
        
        return nil</span>
}

// initializeRepositories sets up the repository manager
func (s *Service) initializeRepositories() error <span class="cov8" title="1">{
        logging.Info("Initializing repositories")
        
        // TODO: Initialize actual repository implementations
        // For now, we'll just create the repository manager structure
        s.repos = &amp;models.RepositoryManager{
                // Repository implementations will be added in later tasks
        }
        
        logging.Info("Repositories initialized successfully")
        return nil
}</span>

// writePIDFile creates a PID file containing the current process ID
func (s *Service) writePIDFile() error <span class="cov8" title="1">{
        pidDir := filepath.Dir(s.config.PIDFile)
        if err := os.MkdirAll(pidDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PID directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">pid := os.Getpid()
        pidStr := strconv.Itoa(pid)
        
        if err := os.WriteFile(s.config.PIDFile, []byte(pidStr), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write PID file: %w", err)
        }</span>
        
        <span class="cov8" title="1">logging.Info("PID file created", logging.String("path", s.config.PIDFile), logging.Int("pid", pid))
        return nil</span>
}

// removePIDFile removes the PID file
func (s *Service) removePIDFile() <span class="cov8" title="1">{
        if err := os.Remove(s.config.PIDFile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                logging.Error("Failed to remove PID file", logging.Err(err))
        }</span> else<span class="cov8" title="1"> {
                logging.Info("PID file removed", logging.String("path", s.config.PIDFile))
        }</span>
}

// setupSignalHandling configures signal handlers for graceful shutdown
func (s *Service) setupSignalHandling() <span class="cov8" title="1">{
        signals := make(chan os.Signal, 1)
        signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)
        
        go func() </span><span class="cov8" title="1">{
                sig := &lt;-signals
                logging.Info("Received shutdown signal", logging.String("signal", sig.String()))
                
                if err := s.Stop(); err != nil </span><span class="cov0" title="0">{
                        logging.Error("Error during shutdown", logging.Err(err))
                        os.Exit(1)
                }</span>
        }()
}

// healthCheckRoutine runs periodic health checks
func (s *Service) healthCheckRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(s.config.HealthCheckInterval)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if err := s.IsHealthy(); err != nil </span><span class="cov8" title="1">{
                                logging.Error("Health check failed", logging.Err(err))
                                s.addError(err)
                        }</span>
                }
        }
}

// cleanup performs cleanup tasks during shutdown
func (s *Service) cleanup(ctx context.Context) <span class="cov8" title="1">{
        logging.Info("Performing cleanup tasks")
        
        // Close database connection
        if s.db != nil </span><span class="cov8" title="1">{
                if err := s.db.Close(); err != nil </span><span class="cov0" title="0">{
                        logging.Error("Error closing database", logging.Err(err))
                }</span>
        }
        
        // Remove PID file
        <span class="cov8" title="1">s.removePIDFile()
        
        logging.Info("Cleanup completed")</span>
}

// setState safely updates the service state
func (s *Service) setState(state ServiceState) <span class="cov8" title="1">{
        s.stateMu.Lock()
        defer s.stateMu.Unlock()
        
        oldState := s.state
        s.state = state
        
        if oldState != state </span><span class="cov8" title="1">{
                logging.Info("Service state changed", 
                        logging.String("from", oldState.String()), 
                        logging.String("to", state.String()))
        }</span>
}

// getState safely retrieves the current service state
func (s *Service) getState() ServiceState <span class="cov8" title="1">{
        s.stateMu.RLock()
        defer s.stateMu.RUnlock()
        return s.state
}</span>

// addError safely adds an error to the error list
func (s *Service) addError(err error) <span class="cov8" title="1">{
        s.errorsMu.Lock()
        defer s.errorsMu.Unlock()
        
        s.errors = append(s.errors, err)
        
        // Keep only the last 10 errors to prevent memory growth
        if len(s.errors) &gt; 10 </span><span class="cov0" title="0">{
                s.errors = s.errors[len(s.errors)-10:]
        }</span>
} </pre>
		
		<pre class="file" id="file7" style="display: none">package testutil

import (
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "testing"
        "time"

        "parental-control/internal/config"
        "parental-control/internal/database"
        "parental-control/internal/logging"
        "parental-control/internal/models"
)

// TestDatabase provides a test database instance with utilities
type TestDatabase struct {
        DB      *database.DB
        TempDir string
        Config  database.Config
}

// NewTestDatabase creates a new test database instance in a temporary directory
func NewTestDatabase(t *testing.T) *TestDatabase <span class="cov8" title="1">{
        t.Helper()

        tempDir := t.TempDir()
        dbPath := filepath.Join(tempDir, "test.db")

        config := database.Config{
                Path:         dbPath,
                MaxOpenConns: 5,
                MaxIdleConns: 2,
                EnableWAL:    true,
        }

        db, err := database.New(config)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>

        <span class="cov8" title="1">if err := db.InitializeSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                t.Fatalf("Failed to initialize test database schema: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;TestDatabase{
                DB:      db,
                TempDir: tempDir,
                Config:  config,
        }</span>
}

// Cleanup closes the database and cleans up temporary files
func (td *TestDatabase) Cleanup() <span class="cov8" title="1">{
        if td.DB != nil </span><span class="cov8" title="1">{
                td.DB.Close()
        }</span>
}

// Reset clears all data from the database while keeping the schema
func (td *TestDatabase) Reset(t *testing.T) <span class="cov8" title="1">{
        t.Helper()

        // Clear all tables
        tables := []string{
                "quota_usage", "audit_log", "quota_rules", "time_rules",
                "list_entries", "lists", "config",
        }

        for _, table := range tables </span><span class="cov8" title="1">{
                _, err := td.DB.Connection().Exec(fmt.Sprintf("DELETE FROM %s", table))
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to clear table %s: %v", table, err)
                }</span>
        }
}

// TestConfig provides test configuration utilities
type TestConfig struct {
        Config   *config.Config
        TempDir  string
        FilePath string
}

// NewTestConfig creates a new test configuration
func NewTestConfig(t *testing.T) *TestConfig <span class="cov8" title="1">{
        t.Helper()

        tempDir := t.TempDir()
        configPath := filepath.Join(tempDir, "test-config.yaml")

        cfg := config.Default()
        cfg.Service.DataDirectory = tempDir
        cfg.Service.PIDFile = filepath.Join(tempDir, "test.pid")
        cfg.Database.Path = filepath.Join(tempDir, "test.db")
        cfg.Security.EnableAuth = false
        cfg.Monitoring.Enabled = false

        return &amp;TestConfig{
                Config:   cfg,
                TempDir:  tempDir,
                FilePath: configPath,
        }
}</span>

// SaveToFile saves the test configuration to file
func (tc *TestConfig) SaveToFile(t *testing.T) <span class="cov8" title="1">{
        t.Helper()

        if err := tc.Config.SaveToFile(tc.FilePath); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to save test config: %v", err)
        }</span>
}

// TestLogger provides test logging utilities
type TestLogger struct {
        Logger *logging.Logger
        Level  string
}

// NewTestLogger creates a logger suitable for testing
func NewTestLogger(t *testing.T) *TestLogger <span class="cov8" title="1">{
        t.Helper()

        // Create a logger configuration for testing
        logConfig := logging.Config{
                Level:  logging.WARN,
                Output: os.Stdout,
        }

        logger := logging.New(logConfig)

        return &amp;TestLogger{
                Logger: logger,
                Level:  "WARN",
        }
}</span>

// Quiet sets the logger to only output errors and fatals
func (tl *TestLogger) Quiet() <span class="cov8" title="1">{
        tl.Logger.SetLevel(logging.ERROR)
        tl.Level = "ERROR"
}</span>

// Verbose sets the logger to output all messages
func (tl *TestLogger) Verbose() <span class="cov8" title="1">{
        tl.Logger.SetLevel(logging.DEBUG)
        tl.Level = "DEBUG"
}</span>

// TestFixtures provides test data fixtures
type TestFixtures struct {
        Config     models.Config
        Lists      []models.List
        Entries    []models.ListEntry
        TimeRule   models.TimeRule
        QuotaRule  models.QuotaRule
        QuotaUsage models.QuotaUsage
        AuditLog   models.AuditLog
}

// NewTestFixtures creates a set of test data fixtures
func NewTestFixtures() *TestFixtures <span class="cov8" title="1">{
        now := time.Now()

        return &amp;TestFixtures{
                Config: models.Config{
                        ID:          1,
                        Key:         "test_setting",
                        Value:       "test_value",
                        Description: "Test configuration setting",
                        CreatedAt:   now,
                        UpdatedAt:   now,
                },
                Lists: []models.List{
                        {
                                ID:          1,
                                Name:        "Allowed Sites",
                                Type:        models.ListTypeWhitelist,
                                Description: "List of allowed websites",
                                Enabled:     true,
                                CreatedAt:   now,
                                UpdatedAt:   now,
                        },
                        {
                                ID:          2,
                                Name:        "Blocked Sites",
                                Type:        models.ListTypeBlacklist,
                                Description: "List of blocked websites",
                                Enabled:     true,
                                CreatedAt:   now,
                                UpdatedAt:   now,
                        },
                },
                Entries: []models.ListEntry{
                        {
                                ID:          1,
                                ListID:      1,
                                EntryType:   models.EntryTypeURL,
                                Pattern:     "example.com",
                                PatternType: models.PatternTypeDomain,
                                Description: "Example domain",
                                Enabled:     true,
                                CreatedAt:   now,
                                UpdatedAt:   now,
                        },
                        {
                                ID:          2,
                                ListID:      2,
                                EntryType:   models.EntryTypeURL,
                                Pattern:     "blocked.com",
                                PatternType: models.PatternTypeDomain,
                                Description: "Blocked domain",
                                Enabled:     true,
                                CreatedAt:   now,
                                UpdatedAt:   now,
                        },
                },
                TimeRule: models.TimeRule{
                        ID:         1,
                        ListID:     1,
                        Name:       "School Hours",
                        RuleType:   models.RuleTypeAllowDuring,
                        DaysOfWeek: []int{1, 2, 3, 4, 5}, // Monday to Friday
                        StartTime:  "08:00",
                        EndTime:    "16:00",
                        Enabled:    true,
                        CreatedAt:  now,
                        UpdatedAt:  now,
                },
                QuotaRule: models.QuotaRule{
                        ID:           1,
                        ListID:       1,
                        Name:         "Daily Limit",
                        QuotaType:    models.QuotaTypeDaily,
                        LimitSeconds: 3600, // 1 hour
                        Enabled:      true,
                        CreatedAt:    now,
                        UpdatedAt:    now,
                },
                QuotaUsage: models.QuotaUsage{
                        ID:          1,
                        QuotaRuleID: 1,
                        PeriodStart: now.Add(-24 * time.Hour),
                        PeriodEnd:   now,
                        UsedSeconds: 1800, // 30 minutes
                        CreatedAt:   now,
                        UpdatedAt:   now,
                },
                AuditLog: models.AuditLog{
                        ID:          1,
                        Timestamp:   now,
                        EventType:   "access_attempt",
                        TargetType:  models.TargetTypeURL,
                        TargetValue: "example.com",
                        Action:      models.ActionTypeAllow,
                        CreatedAt:   now,
                },
        }
}</span>

// AssertNoError fails the test if err is not nil
func AssertNoError(t *testing.T, err error) <span class="cov8" title="1">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Unexpected error: %v", err)
        }</span>
}

// AssertError fails the test if err is nil
func AssertError(t *testing.T, err error) <span class="cov8" title="1">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("Expected error but got nil")
        }</span>
}

// AssertErrorContains fails the test if err is nil or doesn't contain expectedText
func AssertErrorContains(t *testing.T, err error, expectedText string) <span class="cov8" title="1">{
        t.Helper()
        if err == nil </span><span class="cov0" title="0">{
                t.Fatal("Expected error but got nil")
        }</span>
        <span class="cov8" title="1">if !ContainsString(err.Error(), expectedText) </span><span class="cov0" title="0">{
                t.Fatalf("Expected error to contain '%s', but got: %v", expectedText, err)
        }</span>
}

// AssertEqual fails the test if expected != actual
func AssertEqual[T comparable](t *testing.T, expected, actual T) <span class="cov8" title="1">{
        t.Helper()
        if expected != actual </span><span class="cov0" title="0">{
                t.Fatalf("Expected %v, got %v", expected, actual)
        }</span>
}

// AssertNotEqual fails the test if notExpected == actual
func AssertNotEqual[T comparable](t *testing.T, notExpected, actual T) <span class="cov8" title="1">{
        t.Helper()
        if notExpected == actual </span><span class="cov0" title="0">{
                t.Fatalf("Expected not %v, but got %v", notExpected, actual)
        }</span>
}

// AssertTrue fails the test if condition is false
func AssertTrue(t *testing.T, condition bool) <span class="cov8" title="1">{
        t.Helper()
        if !condition </span><span class="cov0" title="0">{
                t.Fatal("Expected condition to be true")
        }</span>
}

// AssertFalse fails the test if condition is true
func AssertFalse(t *testing.T, condition bool) <span class="cov8" title="1">{
        t.Helper()
        if condition </span><span class="cov0" title="0">{
                t.Fatal("Expected condition to be false")
        }</span>
}

// AssertNil fails the test if value is not nil
func AssertNil(t *testing.T, value interface{}) <span class="cov8" title="1">{
        t.Helper()
        if value == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Handle typed nil values (like (*int)(nil))
        <span class="cov8" title="1">v := reflect.ValueOf(value)
        if !v.IsValid() || (v.Kind() == reflect.Ptr &amp;&amp; v.IsNil()) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">t.Fatalf("Expected nil, got %v", value)</span>
}

// AssertNotNil fails the test if value is nil
func AssertNotNil(t *testing.T, value interface{}) <span class="cov8" title="1">{
        t.Helper()
        if value == nil </span><span class="cov0" title="0">{
                t.Fatal("Expected non-nil value")
        }</span>
}

// ContainsString checks if s contains substr
func ContainsString(s, substr string) bool <span class="cov8" title="1">{
        return findString(s, substr)
}</span>

// findString is a simple string contains check
func findString(s, substr string) bool <span class="cov8" title="1">{
        if len(substr) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// TimeWithinDelta checks if two times are within delta of each other
func TimeWithinDelta(t1, t2 time.Time, delta time.Duration) bool <span class="cov8" title="1">{
        diff := t1.Sub(t2)
        if diff &lt; 0 </span><span class="cov8" title="1">{
                diff = -diff
        }</span>
        <span class="cov8" title="1">return diff &lt;= delta</span>
}

// AssertTimeWithinDelta fails the test if expected and actual times are not within delta
func AssertTimeWithinDelta(t *testing.T, expected, actual time.Time, delta time.Duration) <span class="cov8" title="1">{
        t.Helper()
        if !TimeWithinDelta(expected, actual, delta) </span><span class="cov0" title="0">{
                t.Fatalf("Expected time %v to be within %v of %v", actual, delta, expected)
        }</span>
}

// WaitForCondition waits for a condition to become true within timeout
func WaitForCondition(condition func() bool, timeout time.Duration) bool <span class="cov8" title="1">{
        deadline := time.Now().Add(timeout)
        for time.Now().Before(deadline) </span><span class="cov8" title="1">{
                if condition() </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov8" title="1">return false</span>
}

// AssertEventually fails the test if condition doesn't become true within timeout
func AssertEventually(t *testing.T, condition func() bool, timeout time.Duration) <span class="cov8" title="1">{
        t.Helper()
        if !WaitForCondition(condition, timeout) </span><span class="cov0" title="0">{
                t.Fatalf("Condition did not become true within %v", timeout)
        }</span>
}

// SetupTestEnvironment creates a complete test environment with database, config, and logger
func SetupTestEnvironment(t *testing.T) (*TestDatabase, *TestConfig, *TestLogger) <span class="cov8" title="1">{
        t.Helper()

        db := NewTestDatabase(t)
        cfg := NewTestConfig(t)
        logger := NewTestLogger(t)

        // Set database path in config to match test database
        cfg.Config.Database = db.Config

        return db, cfg, logger
}</span>

// BenchmarkHelper provides utilities for benchmarking
type BenchmarkHelper struct {
        StartTime time.Time
        EndTime   time.Time
}

// NewBenchmarkHelper creates a new benchmark helper
func NewBenchmarkHelper() *BenchmarkHelper <span class="cov8" title="1">{
        return &amp;BenchmarkHelper{}
}</span>

// Start records the start time
func (bh *BenchmarkHelper) Start() <span class="cov8" title="1">{
        bh.StartTime = time.Now()
}</span>

// Stop records the end time and returns the duration
func (bh *BenchmarkHelper) Stop() time.Duration <span class="cov8" title="1">{
        bh.EndTime = time.Now()
        return bh.Duration()
}</span>

// Duration returns the elapsed time between start and stop
func (bh *BenchmarkHelper) Duration() time.Duration <span class="cov8" title="1">{
        if bh.EndTime.IsZero() </span><span class="cov8" title="1">{
                return time.Since(bh.StartTime)
        }</span>
        <span class="cov8" title="1">return bh.EndTime.Sub(bh.StartTime)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
